// 프로토타입 스코프
- 프로토타입 스코프인 Bean 을 스프링컨테이너에 조회하면 스프링컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다. (싱글톤 X)
    1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청하면
    2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하여, 필요한 의존관계를 주입하고 초기화(@PostConstruct) 까지 호출.
    3. 클라이언트에게 반환함. (더이상 스프링컨테이너에서 관리하지않음.)
    4. 이후에 스프링 컨테이너에 같은 요청이 들어오면 항상 새로운 프로토타입 빈을 생성해서 반환한다. (요청마다 @PostConstruct 가 실행되는것임.)
** 중요 **
- 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것임.
- 클라이언트에게 Bean 을 반환한 이후, 스프링 컨테이너는 해당 Bean 을 관리하지 않음 (빈을 관리할 책임은 반환받은 클라이언트에게 있음.)
  --> 그래서 @PreDestroy 같은 종료 메서드가 호출되지 않음.


// 싱글톤과 프로토타입 차이 (중요)
1. 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화(@PostConstruct) 메서드가 실행 되지만,
   프로토타입 스코프의 빈은 스프링 컨테이너에서 Bean 을 조회할 때 생성되고, 초기화 메서드도 실행된다.
2. 프로토타입 빈을 2번 조회했으므로 완전히 다른 스프링 빈이 생성되고, 초기화도 2번 실행된다.
3. 싱글톤 빈은 스프링 컨테이너가 관리하기 때문에 스프링 컨테이너가 종료될 때 빈의 종료 메서드가 실행되지만,
   프로토타입 빈은 스프링 컨테이너가 생성과 의존관계 주입 그리고 초기화 까지만 관여하고, 더는 관리하지 않는다.
   따라서 프로토타입 빈은 스프링 컨테이너가 종료될 때 @PreDestroy 같은 종료 메서드가 전혀 실행되지 않는다
--> 싱글톤 Bean 은 스프링컨테이너가 내려갈때까지 스프링컨테이너에서 관리됨. (생명주기를 같이함.)
--> 프로토타입 Bean 은 생성, 의존성주입, 초기화까지만 관여하고 스프링컨테이너에서 관리되지 않음.


// 프로토타입 빈의 특징 정리
- 스프링 컨테이너에 요청할 때 마다 새로 생성된다.
- 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.
- 종료 메서드가 호출되지 않는다.
- 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.
  (bean.destroy())
