* 핵심기능과 부가 기능을 분리
- 개발자들은 부가기능을 핵심기능에서 분리하고 한곳에서 관리하도록 하기위해서 Aspect 라는 개념을 만들었다.
- 참고로 스프링에서 제공하는 Advisor 도 Advice(부가기능) 과 Pointcut(적용대상) 을 가지고 있어서 개념상 하나의 Aspect 이다.
- Aspect 는 우리말로 해석하면 "관점" 이라는 뜻인데, 이름 그대로 애플리케이션을 바라보는 관점을
  하나하나의 기능에서 횡단 관심사 (cross cutting concerns) 관점으로 달리 보는 것을 의미한다.
  이렇게 Aspect 를 사용한 프로그래밍 방식을 관점 지향 프로그래밍 AOP(Aspect-Oriented Programming) 이라 한다.
--> 참고로 AOP 는 OOP 를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하게 어려운 OOP 의 부족한 부분을 보조하는 목적으로 개발되었다.

* AspectJ 프레임워크
- AOP 의 대표적인 구현으로 AspectJ 프레임워크가 있다. 물론 스프링도 AOP 를 지원하지만, 대부분 AspectJ 의 문법을 차용하고, AspectJ 가 제공하는
  기능의 일부만 제공한다.
- AspectJ 프레임워크는 스스로를 다음과 같이 설명한다.
1. 자바 프로그래밍 언어에 대한 완벽한 관점 지향확장
2. 횡단 관심사의 깔끔한 모듈화
    - 오류 검사 및 처리
    - 동기화
    - 성능 최적화 (캐싱)
    - 모니터링 및 로깅

* AOP 적용 방식
- AOP 를 사용하면 핵심 기능과 부가 기능이 코드상 완전히 분리되어서 관리된다.
- 그렇다면 AOP 를 사용할 때 부가 기능 로직은 어떤 방식으로 실제 로직에 추가될 수 있을까
- 크게 3가지 방법이 있다.
    - 컴파일 시점
    - 클래스 로딩 시점
    - 런타임 시점 (프록시) --> 이걸 사용함

* AOP 적용 위치
AOP 는 지금까지 학습만 메서드 실행 위치뿐만 아니라 다음과 같은 다양한 위치에서 적용할 수 있다.
- 적용 가능 지점(JoinPoint) : 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
    --> 이렇게 AOP 를 적용할 수 있는 지점을 JoinPoint 라고 한다.
- 그런데 프록시 방식을 사용하는 Spring AOP 는 메서드 실행 지점에만 AOP 를 적용할 수 있다. --> 중요
    --> 프록시는 메서드 Overriding 개념으로 동작한다. 따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다.
    --> 프록시를 사용하는 스프링 AOP 의 조인포인트는 메서드 실행으로 제한된다.
- 프록시 방식을 사용하는 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 Spring Bean 에만 AOP 를 적용할 수 있다.
결론 --> Spring 은 AspectJ 의 문법을 차용하고 프록시 방식의 AOP 를 적용한다. 즉, AspectJ 를 직접 사용하는 것이 아니다.
