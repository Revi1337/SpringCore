프록시 방식의 AOP 한계
    - 스프링은 프록시 방식의 AOP 를 사용한다. 프록시 방식의 AOP 는 메서드 내부 호출에 프록시를 적용할 수 없다.
      따라서 지금부터 메서드 내부호출 사이에서 프록시를 적용할 수 없는 이 문제를 해결하는 방법을 하나씩 알아보자.
    - 우선 "프록시 방식의 AOP 는 메서드 내부 호출에 프록시를 적용할 수 없다" 이말은
      같은 프록시 대상 객체 내부에서 서로 다른 메서드를 내부적으로 호출할때는 AOP 가 적용되지 않는 말이다.
        --> 따라서 internal() 에 대한 AOP 는 동작하지 않는다.
        --> 일반적으로 프록시를 통해 target(대상객체) 이 호출되어야 AOP 가 동작한다(즉 외부 참조.).,
            하지만, 프록시의 대상 객체인 target 내부에서 서로 인스턴스 메서드를 호출한다면(즉. 내부 참조)
            프록시가 외부참조를 통해 메서드를 실행시키는 구조가 아니기 때문에, AOP 가 동작하지 않는다. (프록시가 중간에 끼어들 수 없는 구조.)


프록시 방식의 AOP 한계 해결방법

    1. setter 를 통해 자기자신을 의존관계 주입을 해주어. 메서드참조를 내부참조에서 외부참조로 변경하는 방법.
        --> 만약, 여기서 생성자주입으로 자기자신을 주입받게되면 오류가 뜸. 왜냐? 자기자신을 주입받기때문에 순환참조가 발생함.
        --> 따라서 setter 를 통해 의존관계 주입을 해준다.
            --> 하지만..스프링 부트 2.6 릴리즈 노트를 확인해보니 순환 참조를 기본적으로 금지하도록 변경되었다.
                따라서 순환 참조를 허용하도록 해결하려면 application.properties 파일에 다음을 추가해야 한다.
                `spring.main.allow-circular-references=true`
        --> 그리고 기존 내부메서드 참조를 주입받은 프록시객체의 메서드 참조로 변경해준다.  (외부 참조)

    2. 지연조회를 통해 메서드 참조를 내부참조에서 외부참조로 변경하는 방법
        --> 앞서 생성자주입이 실패하는 이유는 자기 자신을 생성하면서 주입해야하기 때문이다. 이 경우 setter 주입이나 지연조회를 통해 자기자신을 주입받으면 된다.
        --> 지연조회를 통해 메서드 참조를 내부참조에서 외부참조로 변경하는 방법에서 두가지가 있다.
            1. 무식하게 ApplicationContext 를 주입받아, 프록시 객체의 대상이 되는 객체 타입의 Bean 을 꺼내서 지연로딩을 흉내내는 방법.
                --> 하지만 ApplicationContext 는 너무 거대하고 기능이 많아.. 비추..
            2. ObjectProvider 를 통해 지연로딩을 사용하는 방법.

    3. 1번과 2번 방법들은 자기자신을 주입하거나 또는 Provider 를 사용해야 하는것처럼 조금 어색한 방법이다.
       가장 나은 대안은 내부 호출이 발생하지 않도록 구조 자체를 변경하는 것이다. Spring 에서도 실제로 이 방법을 제일 권장하고 있다.


프록시 기술과 한계 - 타입 캐스팅
    - JDK 동적 프록시와 CGLIB 를 사용해서 AOP 프록시를 방법에는 각각 장단점이 있다.
    - JDK 동적 프록시는 인터페이스가 필수이고, 인터페이스를 기반으로 프록시를 생성한다.
    - CGLIB 는 구체 클래스를 기반으로 프록시를 생성한다.
    - 물론 Interface 가 없고, 구체클래스만 있는 경우에는 CGLIB 를 사용해야 한다.
      그런데 인터페이스가 있는 경우에는 JDK 동적 프록시나 CGLIB 둘중에 하나를 선택할 수 있다.
    - 스프링이 프록시를 만들때 제공하는 ProxyFactory 에 proxyTargetClass 옵션에 따라 중 중 하나를선택해서 프록시를 만들 수 있다.
    - proxyTargetClass = false --> JDK 동적 프록시를 사용해서 인터페이스 기반 프록시를 생성.
      proxyTargetClass = true --> CGLIB 를 사용해서 구체 클래스 기반 프록시를 생성
    - 참고로 옵션과 무관하게 인터페이스가 없으면 JDK 동적 프록시를 적용할 수 없으므로 CGLIB 를 사용한다.

    * 정리 *
    --> JDK 동적 프록시는 대상 객체인 MemberSerivceImpl 로 캐스팅할 수 없다.
        JDK 동적 프록시는 MemverService 구현한것이지. MemberServiceImpl 은 뭔지도 모르기 때문임.
    --> CGLIB 프록시는 대상 객체인 MemberServiceImpl 로 캐스팅 할 수 있다.
        왜냐하면 CGLIB 프록시는 프록시 대상 객체 그 자체 (여기서는 MemverServiceImpl 구현체) 를 상속받아 프록시를 생성한것이기 때문에 가능하다.

    ** 그런데 프록시를 캐스팅 할 일이 많지 않을 것 같은데 왜 이야기를 할까? 진짜 문제는 의존관계 주입시에 발생한다.