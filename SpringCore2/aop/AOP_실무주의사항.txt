프록시 방식의 AOP 한계
    - 스프링은 프록시 방식의 AOP 를 사용한다. 프록시 방식의 AOP 는 메서드 내부 호출에 프록시를 적용할 수 없다.
      따라서 지금부터 메서드 내부호출 사이에서 프록시를 적용할 수 없는 이 문제를 해결하는 방법을 하나씩 알아보자.
    - 우선 "프록시 방식의 AOP 는 메서드 내부 호출에 프록시를 적용할 수 없다" 이말은
      같은 프록시 대상 객체 내부에서 서로 다른 메서드를 내부적으로 호출할때는 AOP 가 적용되지 않는 말이다.
        --> 따라서 internal() 에 대한 AOP 는 동작하지 않는다.
        --> 일반적으로 프록시를 통해 target(대상객체) 이 호출되어야 AOP 가 동작한다(즉 외부 참조.).,
            하지만, 프록시의 대상 객체인 target 내부에서 서로 인스턴스 메서드를 호출한다면(즉. 내부 참조)
            프록시가 외부참조를 통해 메서드를 실행시키는 구조가 아니기 때문에, AOP 가 동작하지 않는다. (프록시가 중간에 끼어들 수 없는 구조.)


프록시 방식의 AOP 한계 해결방법

    1. setter 를 통해 자기자신을 의존관계 주입을 해주어. 메서드참조를 내부참조에서 외부참조로 변경하는 방법.
        --> 만약, 여기서 생성자주입으로 자기자신을 주입받게되면 오류가 뜸. 왜냐? 자기자신을 주입받기때문에 순환참조가 발생함.
        --> 따라서 setter 를 통해 의존관계 주입을 해준다.
            --> 하지만..스프링 부트 2.6 릴리즈 노트를 확인해보니 순환 참조를 기본적으로 금지하도록 변경되었다.
                따라서 순환 참조를 허용하도록 해결하려면 application.properties 파일에 다음을 추가해야 한다.
                `spring.main.allow-circular-references=true`
        --> 그리고 기존 내부메서드 참조를 주입받은 프록시객체의 메서드 참조로 변경해준다.  (외부 참조)

    2. 지연조회를 통해 메서드 참조를 내부참조에서 외부참조로 변경하는 방법
        --> 앞서 생성자주입이 실패하는 이유는 자기 자신을 생성하면서 주입해야하기 때문이다. 이 경우 setter 주입이나 지연조회를 통해 자기자신을 주입받으면 된다.
        --> 지연조회를 통해 메서드 참조를 내부참조에서 외부참조로 변경하는 방법에서 두가지가 있다.
            1. 무식하게 ApplicationContext 를 주입받아, 프록시 객체의 대상이 되는 객체 타입의 Bean 을 꺼내서 지연로딩을 흉내내는 방법.
                --> 하지만 ApplicationContext 는 너무 거대하고 기능이 많아.. 비추..
            2. ObjectProvider 를 통해 지연로딩을 사용하는 방법.

    3. 1번과 2번 방법들은 자기자신을 주입하거나 또는 Provider 를 사용해야 하는것처럼 조금 어색한 방법이다.
       가장 나은 대안은 내부 호출이 발생하지 않도록 구조 자체를 변경하는 것이다. Spring 에서도 실제로 이 방법을 제일 권장하고 있다.


프록시 기술과 한계 - 타입 캐스팅
    - JDK 동적 프록시와 CGLIB 를 사용해서 AOP 프록시를 방법에는 각각 장단점이 있다.
    - JDK 동적 프록시는 인터페이스가 필수이고, 인터페이스를 기반으로 프록시를 생성한다.
    - CGLIB 는 구체 클래스를 기반으로 프록시를 생성한다.
    - 물론 Interface 가 없고, 구체클래스만 있는 경우에는 CGLIB 를 사용해야 한다.
      그런데 인터페이스가 있는 경우에는 JDK 동적 프록시나 CGLIB 둘중에 하나를 선택할 수 있다.
    - 스프링이 프록시를 만들때 제공하는 ProxyFactory 에 proxyTargetClass 옵션에 따라 중 중 하나를선택해서 프록시를 만들 수 있다.
    - proxyTargetClass = false --> JDK 동적 프록시를 사용해서 인터페이스 기반 프록시를 생성.
      proxyTargetClass = true --> CGLIB 를 사용해서 구체 클래스 기반 프록시를 생성
    - 참고로 옵션과 무관하게 인터페이스가 없으면 JDK 동적 프록시를 적용할 수 없으므로 CGLIB 를 사용한다.

    * 정리 *
    --> JDK 동적 프록시는 대상 객체인 MemberSerivceImpl 로 캐스팅할 수 없다.
        JDK 동적 프록시는 MemverService 구현한것이지. MemberServiceImpl 은 뭔지도 모르기 때문임.
    --> CGLIB 프록시는 대상 객체인 MemberServiceImpl 로 캐스팅 할 수 있다.
        왜냐하면 CGLIB 프록시는 프록시 대상 객체 그 자체 (여기서는 MemverServiceImpl 구현체) 를 상속받아 프록시를 생성한것이기 때문에 가능하다.

    ** 그런데 프록시를 캐스팅 할 일이 많지 않을 것 같은데 왜 이야기를 할까? 진짜 문제는 의존관계 주입시에 발생한다.


프록시 기술과 한계 - 의존 관계 주입
    ** 결론으로는 JDK 동적 프록시로 프록시 객체를 만들면 무조건 인터페이스 기반으로 의존성 주입을 해야한다.
        --> JDK 동적 프록시는 대상 객체인 MemberSerivceImpl 타입에 의존관계를 주입할 수 없다.
    ** 하지만, CGLIB 로 프록시 객체를 만들면, 인터페이스 및 구현체로도 의존성 주입을 할 수 있다.
        --> CGLIB 프록시는 대상 객체인 MemberServiceImpl 타입에 의존관계 주입을 할 수 있다.

    --> 실제로 개발할때는 인터페이스가 있으면 인터페이스를 기반으로 의존관계 주입을 받는것이 맞다.
        DI 의 장점은 DI 받는 Client 코드의 변경 없이 구현 클래스를 변경할 수 있다는 것이다(OCP 를 지킬 수 있는 것).
        이렇게 하려면 인터페이스 기반으로 의존관계를 주입받아야한다.
    --> 여러가지 이유로 AOP 프록시가 적용된 구체 클래스를 직접 의존관계 주입을 받아야하는 경우가 있을 수 있다.
        이때는 CGLIB 를 통해 구체 클래스 기반으로 AOP 프록시를 적용하면 된다.
    --> 여기까지 듣고보면 CGLIB 를 사용하는것이 좋아보인다. CGLIB 를 사용하면 사실 이런 고민 자체를 하지않아도 된다.
        하지만 CGLIB 에는 단점이 있다.


CGLIB 의 단점
    1. 대상 클래스에 기본 생성자 필수
        --> CGLIB 는 구체 클래스를 상속받는다. 자바에서 상속을 받으면 자식 클래스의 생성자를 호출할 때 자식 클래스의 생성자에서 부모 클래스의 생성자도
            같이 호출해야 한다. (이 부분이 생략되어있다면 자식 클래스의 생성자 첫줄에 부모 클래스의 기본 생성자를 호출하는 super() 가 자동으로 들어간다. 뭐 이건 기본이고..)
    2. 생성자 2번 호출 문제
        --> CGLIB 는 구체 클래스를 상속받는다. 자바는 상속을 받으면 자식 클래스의 생성자를 호출할때 부모 클래스의 생성자도 호출해야 한다. 그런데 왜 두번일까?
            1. 실제 target 의 객체를 생성할 때
            2. 프록시 객체를 생성할 때 부모 클래스의 생성자 호출
    3. final 키워드 클래스, 메서드 사용 불가
        --> final 이 클래스에있으면 상속이 불가능. 메서드에 있으며 오버라이딩이 불가능. CGLIB 는 상속을 기반으로 하기 때문에
            두 경우 프록시가 생성되지 않거나 정상 동작하지 않는다.
    ** 정리 **
    JDK 동적 프록시는 대상 클래스 타입으로 의존성을 주입할때 문제가 있고,
    CGLIB 는 대상 클래스에 기본 생성자가 필수이며 생성자가 2번 호출되는 문제가 있다.
    그렇다면 스프링은 어떤 방법을 권장할까..
