프록시 방식의 AOP 한계
    - 스프링은 프록시 방식의 AOP 를 사용한다. 프록시 방식의 AOP 는 메서드 내부 호출에 프록시를 적용할 수 없다.
      따라서 지금부터 메서드 내부호출 사이에서 프록시를 적용할 수 없는 이 문제를 해결하는 방법을 하나씩 알아보자.
    - 우선 "프록시 방식의 AOP 는 메서드 내부 호출에 프록시를 적용할 수 없다" 이말은
      같은 프록시 대상 객체 내부에서 서로 다른 메서드를 내부적으로 호출할때는 AOP 가 적용되지 않는 말이다.
        --> 따라서 internal() 에 대한 AOP 는 동작하지 않는다.
        --> 일반적으로 프록시를 통해 target(대상객체) 이 호출되어야 AOP 가 동작한다(즉 외부 참조.).,
            하지만, 프록시의 대상 객체인 target 내부에서 서로 인스턴스 메서드를 호출한다면(즉. 내부 참조)
            프록시가 외부참조를 통해 메서드를 실행시키는 구조가 아니기 때문에, AOP 가 동작하지 않는다. (프록시가 중간에 끼어들 수 없는 구조.)


프록시 방식의 AOP 한계 해결방법

    1. setter 를 통해 자기자신을 의존관계 주입을 해주어. 메서드참조를 내부참조에서 외부참조로 변경하는 방법.
        --> 만약, 여기서 생성자주입으로 자기자신을 주입받게되면 오류가 뜸. 왜냐? 자기자신을 주입받기때문에 순환참조가 발생함.
        --> 따라서 setter 를 통해 의존관계 주입을 해준다.
            --> 하지만..스프링 부트 2.6 릴리즈 노트를 확인해보니 순환 참조를 기본적으로 금지하도록 변경되었다.
                따라서 순환 참조를 허용하도록 해결하려면 application.properties 파일에 다음을 추가해야 한다.
                `spring.main.allow-circular-references=true`
        --> 그리고 기존 내부메서드 참조를 주입받은 프록시객체의 메서드 참조로 변경해준다.  (외부 참조)

    2. 지연조회를 통해 메서드 참조를 내부참조에서 외부참조로 변경하는 방법
        --> 앞서 생성자주입이 실패하는 이유는 자기 자신을 생성하면서 주입해야하기 때문이다. 이 경우 setter 주입이나 지연조회를 통해 자기자신을 주입받으면 된다.
        --> 지연조회를 통해 메서드 참조를 내부참조에서 외부참조로 변경하는 방법에서 두가지가 있다.
            1. 무식하게 ApplicationContext 를 주입받아, 프록시 객체의 대상이 되는 객체 타입의 Bean 을 꺼내서 지연로딩을 흉내내는 방법.
                --> 하지만 ApplicationContext 는 너무 거대하고 기능이 많아.. 비추..
            2. ObjectProvider 를 통해 지연로딩을 사용하는 방법.
